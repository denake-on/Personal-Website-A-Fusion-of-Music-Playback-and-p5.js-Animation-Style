# 2025阿里Qwen3-coder挑战赛最佳人气奖作品：AHDH任务规划工具
<img src="./assets/media/images/c1_1.jpg" style="width:50%;" >

本篇记录参赛策略、创作过程与项目开发后续计划。

## 名字
我们的项目中文名叫做《未完》。

这是我很喜欢的一张后摇滚专辑的名字，乐队在专辑简介里说这张专辑⌈带有探索、尝试的印记⌋，说⌈把疼痛转化为未完成的力量，我们还想做的更多…而一切并未结束，就像，每首歌结束的时候，都会在残酷中找到希望。⌋

这个项目刚开始的时候，其实我一直感到一种很迷茫的阵痛。如果继续做开发搞技术，可能三四十岁就被优化了，往近了看可能毕业都没有工作；做算法很多公司又在要求发文章，可是做研究好像也不是我喜欢的事情。

这也是网站主页写的那句话第一次浮现在我脑海里：大道晦兮非我欲兮。

科技的发展即将把我们从劳动中解放出来，却在一个劳动者社会引起了恐慌。某种人造的东西开始替我思考和说话，而我不知道还有什么东西值得我为之去争取把人从劳动中解放出来的自由。以前甚至还有人愿意利用我的年轻和聪明才智赚钱，现在我的年轻和聪明好像都没有了意义。

当时项目的另一位主创跟我说，不需要知道自己当下想要什么，只需要知道现在不想要什么就好了。因此这个项目变成了对新道路的小小探索。

希望我也能在残酷中找到希望。

## 产品功能
todolist虽然是每个程序员必做的项目，但是把它做好、做得实用有效，真正帮助人们提升效率却并不是容易的事情。

《未完》的创新点在于【拆解】，也是针对我们的目标人群即ADHD启动困难群体设计的功能。把一个大任务逐步分割成小任务，从最基础的开始，一步步攻克最难的部分。
- 首页四象限视图，有我们专门设计的可爱小鼠IP，直观的进度图，根据优先级和截止事件返回的紧急任务，以及所有任务的时间分配日历视图。
<img src="./assets/media/images/c1_3.png" style="width:70%;" >

- 鼠标悬停即可在日历上查看任务对应的日期
<img src="./assets/media/images/c1_2.png" style="width:70%;" >

- 任务管理支持多级任务视图，可对每一项任务进行手动的拆分，细化任务，分步完成，帮助ADHD启动困难人群从小任务开始，逐步完成大的任务。
<img src="./assets/media/images/c1_5.png" style="width:70%;" >

- 产品一大特点在于能够使用AI帮忙拆分任务，给出专业建议，一键轻松规划。是不是很符合启动困难人群的特征？甚至不用动手拆分，AI会做好一切。
<img src="./assets/media/images/c1_6.jpg" style="width:50%;" >


## 技术架构
### 技术栈
- 后端：FastAPI + SQLAlchemy + SQLite
- 前端：Vue3 + Vite + TailwindCSS + ECharts
- AI集成：OpenRouter API
<img src="./assets/media/images/c1_8.png" style="width:50%;" >

<img src="./assets/media/images/c1_9.png" style="width:50%;" >


### 技术实现部分重点
#### 前后端通信
《未完》这个项目主要采用的是前后端分离的结构，前端使用了**VUE3**作为核心框架，结合**HTML, CSS, JavaScript**构建用户界面，后端采用的是**FastAPI**框架。

前后端的通信基于**RESTful API**设计原则，规范接口命名，通过HTTP协议传输JSON格式的数据，包括：
- 任务数据：任务ID、标题、描述、截止日期、状态（未开始/进行中/已完成）、优先级（高/中/低）、完成进度百分比、任务层级、父任务ID等
-  用户输入数据：新建任务的表单数据、任务更新信息、搜索和筛选参数、AI任务拆解的提示词等

前后端通信中使用的关键技术包括（其实是我新学到的东西）：
- Vite的代理配置实现开发环境的跨域请求处理
即通过Vite服务器功能，将前端请求转发到后端服务器，从而解决浏览器同源策略限制的跨域问题。
```
    1 export default defineConfig({
    2   server: {
    3     proxy: {
    4       '/api': {
    5         target: 'http://localhost:8000',
    6         changeOrigin: true,
    7         rewrite: (path) => path.replace(/^\/api/, '')
    8       }
    9     }
   10   }
   11 })
```
- FastAPI的CORS中间件确保生产环境的安全通信
CORS（Cross-Origin Resource Sharing，跨源资源共享）中间件是FastAPI提供的安全机制，用于控制哪些外部源可以访问API资源。由于项目目前采用的是本地部署的方式，因此配置了允许所有来源和所有HTTP方法以及所有请求头的跨域访问。
```
    1 def create_app() -> FastAPI:
    2     app = FastAPI(title="Task Manager EXE Backend", version="0.1.0")
    3
    4     app.add_middleware(
    5         CORSMiddleware,
    6         allow_origins=["*"],  # 允许所有源访问（生产中应限制为具体域名）
    7         allow_credentials=True,
    8         allow_methods=["*"],  # 允许所有HTTP方法
    9         allow_headers=["*"],  # 允许所有请求头
   10     )
```
- Axios作为HTTP客户端库实现前端请求的统一管理
未完前端使用Axios用于发送HTTP请求到后端API。
```
    1 import axios from 'axios';
    2
    3 const API_BASE_URL = 'http://localhost:8000/api';
    4
    5 export const getTasks = async (params = {}) => {
    6   const response = await axios.get(`${API_BASE_URL}/tasks/`, { params });
    7   return response.data;
    8 };
    9
   10 export const createTask = async (taskData) => {
   11   const response = await axios.post(`${API_BASE_URL}/tasks/`, null, {
   12     params: taskData
   13   });
   14   return response.data;
   15 };
```

## 任务层级架构设计
此项目支持任务的1-3级分解结构，以适应注意力缺陷人群的认知特点和任务管理需求。层级架构的实现主要集中于两个方面，即数据库层面和前端展示层面。
- 数据库层面
1. 采用了关联表的设计，通过parent_id字段建立任务间的父子关系。
```
    1 # backend/models.py
    2 class Task(Base):
    3     __tablename__ = "tasks"
    4
    5     id: Mapped[int] = mapped_column(primary_key=True)
    6     title: Mapped[str] = mapped_column(String(255))
    7     description: Mapped[Optional[str]] = mapped_column(Text)
    8     deadline: Mapped[Optional[date]] = mapped_column(Date)
    9     status: Mapped[TaskStatus] = mapped_column(Enum(TaskStatus))
   10     priority: Mapped[TaskPriority] =
      mapped_column(Enum(TaskPriority))
   11     progress_percent: Mapped[int] = mapped_column(Integer, default=0
      )
   12     level: Mapped[int] = mapped_column(Integer, default=1)  #
      任务层级：1-3级
   13     parent_id: Mapped[Optional[int]] = mapped_column(ForeignKey(
      "tasks.id"))  # 自关联外键
   14
   15     # 建立双向关系
   16     parent: Mapped[Optional["Task"]] = relationship("Task",
      remote_side=[id], back_populates="children")
   17     children: Mapped[List["Task"]] = relationship("Task",
      back_populates="parent")
```
如图所示为SQLAlchemy ORM的核心组成部分，定义了数据库表结构和python对象之间的映射关系。任务的层级结构能够通过模型定义中的关系定义体现：
- 自关联外键：每个任务在数据库中的parent_id字段使用自关联外键，只关联其上一级的任务。
- 双向关系定义：即允许通过子任务对象访问其父任务（child_task.parent）以及允许通过父任务对象访问其所有子任务（parent_task.children）
```
    1 # 假设有一个子任务对象
    2 child_task = get_task(db, child_id)
    3
    4 # 通过双向关系访问父任务
    5 parent_task = child_task.parent  # 直接获得父任务对象
    6
    7 # 访问父任务的子任务列表
    8 subtasks = parent_task.children  # 获得所有子任务列表
    9
```
基于以上这种构建方式，我们能够使用SQLAlchemy的递归查询逻辑构建的层级关系。

2. 数据库层级查询实现
基于双向关系的构建，递归查询更加便于实现。
```
 def get_all_descendants(db: Session, parent_id: int) -> List[Task]:
         """
         递归获取任务的所有后代任务
         """
         descendants = []
    
    
         # 获取直接子任务
        children = db.query(Task).filter(Task.parent_id == parent_id).
      all()
   
        for child in children:
            descendants.append(child)
            # 递归获取子任务的后代
            descendants.extend(get_all_descendants(db, child.id))
   
        return descendants
```
```
def get_root_task(db: Session, task_id: int) -> Task:
    19     """
    20     获取任务的顶级父任务（level 1）
    21     """
    22     task = db.query(Task).filter(Task.id == task_id).first()
    23     if not task or not task.parent_id:
    24         return task
    25
    26     current = task
    27     while current.parent_id:
    28         parent = db.query(Task).filter(Task.id ==
        current.parent_id).first()
    29         if not parent:
    30             break
    31         current = parent
    32
    33     return current
```
同时，层级任务的一个重要特点即父任务的状态会影响子任务，即若父任务打勾，则该任务的子任务以及子任务的子任务等（依次类推）全部打勾标记为已完成，也是基于递归查找实现的。前端也采用了递归组件来展示层级任务。
<img src="./assets/media/images/c1_7.png" style="width:50%;" >

## SQLAlchemy数据库管理
  WeiWan项目选用SQLAlchemy作为ORM（对象关系映射）框架来管理SQLite数据库，主要因为其提供了强大的数据库抽象层和灵活的查询API。SQLAlchemy通过定义Python类模型映射到数据库表结构，使开发者能够使用面向对象的方式操作数据库，无需编写复杂的SQL语句，同时保持了对底层SQL的控制能力。在项目中，SQLAlchemy不仅处理了任务表的CRUD操作，如创建任和查询任务，还实现了复杂的关系查询，如递归获取任务的所有后代任务get_all_descendants()函数中的递归查询逻辑、层级任务的关联查询等。
